# -*- coding: utf-8 -*-
"""Updated_interactive_dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qnEWp7TLNoHqiQr-aM916KNl50ZwVrbz

# Final Viz:
"""

import pandas as pd
import os
import dash
import dash_bootstrap_components as dbc
from dash import dcc, html, clientside_callback, ClientsideFunction
from dash.dependencies import Input, Output, State
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load Data:
file_path = 'Cleaned_data_sheet.xlsx'
try:
    data = pd.read_excel(file_path)
    data.columns = data.columns.str.strip()
except Exception as e:
    print(f"Error loading data: {e}")
    data = pd.DataFrame()

practices = ['Corporate Venture Capital', 'Accelerators & Incubators', 'Venture Building', 'Venture Clienting',
             'Mentorship', 'Business services', 'Workspace', 'Events']

# Define Wharton color palette:
WHARTON_BLUE = '#011F5B'
WHARTON_RED = '#990000'

# Extended palette based on Wharton/Penn colors with complementary colors:
WHARTON_PALETTE = [
    WHARTON_BLUE,
    WHARTON_RED,
    '#2457A7',
    '#C1292E',
    '#4E6396',
    '#D9D9D9',
    '#6A7A99',
    '#BF616A'
]

COLOR_PALETTE = WHARTON_PALETTE

# Define industries to exclude
EXCLUDED_INDUSTRIES = ['Media', 'Real Estate']

# Filter out excluded industries from the dropdown options
available_industries = [ind for ind in sorted(data['industry_new'].dropna().unique())
                       if ind not in EXCLUDED_INDUSTRIES]

# Create a mapping of continents to their countries:
continent_to_countries = {}
for continent in data['Continent'].unique():
    countries_in_continent = data[data['Continent'] == continent]['COUNTRY HEADQUARTERS'].unique()
    continent_to_countries[continent] = sorted(countries_in_continent)

# Filter regions with at least 4 companies:
country_counts = data['COUNTRY HEADQUARTERS'].value_counts()
valid_countries = country_counts[country_counts >= 4].index.tolist()

continent_counts = data['Continent'].value_counts()
valid_continents = continent_counts[continent_counts >= 4].index.tolist()

# App Setup with responsive theme:
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Configure dev tools
app.config.suppress_callback_exceptions = True

# Add responsive meta tag
app.index_string = '''
<!DOCTYPE html>
<html>
    <head>
        {%metas%}
        <title>{%title%}</title>
        {%favicon%}
        {%css%}
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            /* Always apply base padding */
            .container-fluid {
                padding-left: 10px !important;
                padding-right: 10px !important;
            }

            /* Mobile-first responsive styles */
            @media (max-width: 768px) {
                .container-fluid {
                    padding-left: 2px !important;
                    padding-right: 2px !important;
                }

                .card-body {
                    padding: 0.25rem !important;
                }

                h1 {
                    font-size: 1.1rem !important;
                    margin-bottom: 0.5rem !important;
                    line-height: 1.2 !important;
                }

                h4 {
                    font-size: 0.9rem !important;
                }

                .dropdown {
                    margin-bottom: 0.25rem !important;
                }

                .small {
                    font-size: 0.65rem !important;
                }

                .text-danger {
                    font-size: 0.6rem !important;
                }

                .fw-bold {
                    font-size: 0.7rem !important;
                }
            }

            @media (max-width: 480px) {
                h1 {
                    font-size: 0.95rem !important;
                    padding: 0 5px !important;
                }

                .card-header h4 {
                    font-size: 0.8rem !important;
                }

                .container-fluid {
                    padding-left: 1px !important;
                    padding-right: 1px !important;
                }
            }
        </style>
    </head>
    <body>
        {%app_entry%}
        <footer>
            {%config%}
            {%scripts%}
            {%renderer%}
        </footer>
    </body>
</html>
'''

# Updated Layout with responsive classes and new Practice dropdown:
app.layout = dbc.Container(fluid=True, className="px-0 px-md-3", children=[
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Filters", className="text-primary mb-0")),
                dbc.CardBody([
                    dbc.Row([
                        dbc.Col([
                            html.Label("Select Continent(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='continent-dropdown',
                                options=[{'label': cont, 'value': cont} for cont in sorted(valid_continents)],
                                multi=True,
                                placeholder="Select up to 4 continents",
                                className="mb-1"
                            ),
                            html.Div(id='continent-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=3),
                        dbc.Col([
                            html.Label("Select Country(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='country-dropdown',
                                options=[],
                                multi=True,
                                placeholder="Select up to 4 countries",
                                className="mb-1"
                            ),
                            html.Div(id='country-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=3),
                        dbc.Col([
                            html.Label("Select Industry(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='industry-dropdown',
                                options=[{'label': ind, 'value': ind} for ind in available_industries],
                                multi=True,
                                placeholder="Select up to 4 industries",
                                className="mb-1"
                            ),
                            html.Div(id='industry-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=3),
                        dbc.Col([
                            html.Label("Select Practice(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='practice-dropdown',
                                options=[{'label': practice, 'value': practice} for practice in practices],
                                multi=True,
                                placeholder="Select up to 4 practices",
                                className="mb-1"
                            ),
                            html.Div(id='practice-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=3)
                    ]),
                    html.Div([
                        html.Hr(),
                        dbc.Row([
                            dbc.Col([
                                html.Ul([
                                    html.Li("Numbers on the right hand side of the bars indicate the count of companies engaged in each practice"),
                                    html.Li("Continents and countries with fewer than 4 companies according to the chosen filters are excluded from the chart"),
                                    html.Li("When you select practices, the visualization focuses on those specific practices. If you select both industries and practices (without regions), you'll see how each selected industry adopts each selected practice. If you add regions to the mix, you'll get more detailed breakdowns showing practice adoption across both industries and regions"),
                                ],
                                style={
                                    "color": "black",           # all text in black
                                    "listStyleType": "disc",    # small filled circles
                                    "paddingLeft": "1rem",      # indent bullets
                                    "lineHeight": "1.5",        # equal vertical spacing
                                },
                                className="small"              # use Bootstrap's small font
                                )
                            ])
                        ])
                    ], className="mt-2")
                ])
            ])
        ])
    ]),

    # Hidden div to store screen width
    html.Div(id='screen-width', style={'display': 'none'}),

    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    dcc.Loading(
                        id="loading-visualization",
                        type="circle",
                        children=html.Div(id='visualization-container')
                    )
                ])
            ])
        ], width=12)
    ])
])

# Clientside callback to get screen width
clientside_callback(
    """
    function() {
        return window.innerWidth;
    }
    """,
    Output('screen-width', 'children'),
    Input('screen-width', 'id')
)

# Helper function to get responsive layout parameters
def get_responsive_params(screen_width=None):
    # More aggressive mobile settings
    if screen_width is None or screen_width < 576:  # Very small phones
        return {
            'margin_left': 140,
            'margin_right': 15,  # Increased from 5
            'margin_top': 60,
            'margin_bottom': 40,
            'font_size': 11,
            'title_font_size': 11,
            'text_font_size': 11,
            'legend_font_size': 9,
            'height_single': 700,
            'height_subplots': 2200,  # Increased for better spacing
            'legend_x': 1.01,
            'legend_y': 0.99,
            'show_legend_text': False,
            'use_vertical_subplots': True,  # Stack subplots vertically
            'subplot_spacing_v': 0.35,  # Increased vertical spacing
            'subplot_spacing_h': 0.30  # Significantly increased from 0.15
        }
    elif screen_width < 768:  # Small phones/large phones
        return {
            'margin_left': 150,
            'margin_right': 20,  # Increased from 8
            'margin_top': 70,
            'margin_bottom': 50,
            'font_size': 12,
            'title_font_size': 12,
            'text_font_size': 12,
            'legend_font_size': 10,
            'height_single': 750,
            'height_subplots': 2000,  # Increased for better spacing
            'legend_x': 1.01,
            'legend_y': 0.99,
            'show_legend_text': False,
            'use_vertical_subplots': True,  # Stack subplots vertically
            'subplot_spacing_v': 0.32,  # Increased vertical spacing
            'subplot_spacing_h': 0.28  # Significantly increased from 0.15
        }
    elif screen_width < 992:  # Tablet
        return {
            'margin_left': 200,
            'margin_right': 50,  # Increased from 30
            'margin_top': 100,
            'margin_bottom': 80,
            'font_size': 11,
            'title_font_size': 13,
            'text_font_size': 12,
            'legend_font_size': 11,
            'height_single': 700,
            'height_subplots': 1600,  # Increased for better spacing
            'legend_x': 1.02,
            'legend_y': 0.99,
            'show_legend_text': True,
            'use_vertical_subplots': False,
            'subplot_spacing_v': 0.25,  # Increased vertical spacing
            'subplot_spacing_h': 0.25  # Significantly increased from 0.12
        }
    else:  # Desktop
        return {
            'margin_left': 300,
            'margin_right': 80,  # Increased from 50
            'margin_top': 150,
            'margin_bottom': 120,
            'font_size': 13,
            'title_font_size': 16,
            'text_font_size': 14,
            'legend_font_size': 13,
            'height_single': 800,
            'height_subplots': 1800,  # Increased for better spacing
            'legend_x': 1.02,
            'legend_y': 0.99,
            'show_legend_text': True,
            'use_vertical_subplots': False,
            'subplot_spacing_v': 0.22,  # Increased vertical spacing
            'subplot_spacing_h': 0.22  # Significantly increased from 0.12
        }

# Updated callbacks with new limits and practice dropdown
@app.callback(
    Output('country-dropdown', 'options'),
    [Input('continent-dropdown', 'value')]
)
def update_country_options(selected_continents):
    if not selected_continents:
        return [{'label': country, 'value': country} for country in sorted(valid_countries)]

    filtered_countries = []
    for continent in selected_continents:
        if continent in continent_to_countries:
            countries_in_continent = continent_to_countries[continent]
            valid_countries_in_continent = [c for c in countries_in_continent if c in valid_countries]
            filtered_countries.extend(valid_countries_in_continent)

    filtered_countries = sorted(set(filtered_countries))
    return [{'label': country, 'value': country} for country in filtered_countries]

@app.callback(
    Output('country-dropdown', 'value'),
    [Input('country-dropdown', 'options')],
    [State('country-dropdown', 'value')]
)
def reset_country_value(available_options, current_value):
    if not current_value:
        return current_value

    available_values = [option['value'] for option in available_options]
    valid_selections = [val for val in current_value if val in available_values]
    return valid_selections if valid_selections else None

@app.callback(
    [Output('continent-warning', 'children'),
     Output('country-warning', 'children'),
     Output('industry-warning', 'children'),
     Output('practice-warning', 'children'),
     Output('continent-dropdown', 'value', allow_duplicate=True),
     Output('country-dropdown', 'value', allow_duplicate=True),
     Output('industry-dropdown', 'value'),
     Output('practice-dropdown', 'value')],
    [Input('continent-dropdown', 'value'),
     Input('country-dropdown', 'value'),
     Input('industry-dropdown', 'value'),
     Input('practice-dropdown', 'value')],
    prevent_initial_call=True
)
def enforce_limits(continents, countries, industries, selected_practices):
    warn = {'continent': '', 'country': '', 'industry': '', 'practice': ''}

    if continents and len(continents) > 4:
        warn['continent'] = "Maximum 4 continents allowed"
        continents = continents[:4]
    if countries and len(countries) > 4:
        warn['country'] = "Maximum 4 countries allowed"
        countries = countries[:4]
    if industries and len(industries) > 4:
        warn['industry'] = "Maximum 4 industries allowed"
        industries = industries[:4]
    if selected_practices and len(selected_practices) > 4:
        warn['practice'] = "Maximum 4 practices allowed"
        selected_practices = selected_practices[:4]

    return (warn['continent'], warn['country'], warn['industry'], warn['practice'],
            continents, countries, industries, selected_practices)

def get_filtered_data(continents, countries, industries):
    df = data.copy()
    if continents:
        df = df[df['Continent'].isin(continents)]
    if countries:
        df = df[df['COUNTRY HEADQUARTERS'].isin(countries)]
    if industries:
        # Filter out excluded industries even if they somehow get selected
        valid_industries = [ind for ind in industries if ind not in EXCLUDED_INDUSTRIES]
        if valid_industries:
            df = df[df['industry_new'].isin(valid_industries)]
        else:
            # If all selected industries are excluded, return empty dataframe
            df = df.iloc[0:0]
    return df

@app.callback(
    Output('visualization-container', 'children'),
    [Input('continent-dropdown', 'value'),
     Input('country-dropdown', 'value'),
     Input('industry-dropdown', 'value'),
     Input('practice-dropdown', 'value'),
     Input('screen-width', 'children')]
)
def update_visualization(continents, countries, industries, selected_practices, screen_width):
    # Convert screen_width to int if it exists
    try:
        screen_width = int(screen_width) if screen_width else None
    except (ValueError, TypeError):
        screen_width = None

    df = get_filtered_data(continents, countries, industries)
    if df.empty:
        return html.Div("No data available for selected filters", className="text-center text-danger p-4")

    params = get_responsive_params(screen_width)

    # Determine visualization type based on selections
    num_regions = len(countries or continents or [])
    num_industries = len(industries or [])
    num_practices = len(selected_practices or [])

    # Practice-based visualizations
    if selected_practices:
        if num_practices == 1 and num_regions >= 2 and num_industries >= 2:
            # Single practice with multiple industries and regions
            return create_single_practice_chart(df, selected_practices[0], industries, countries, continents, params)
        elif num_practices > 1 and num_regions >= 2 and num_industries >= 2:
            # Multiple practices with multiple industries and regions
            return create_practice_subplots(df, selected_practices, industries, countries, continents, params)
        elif num_industries >= 2 and num_practices >= 1 and num_regions == 0:
            # Multiple industries with selected practices (no regions specified)
            return create_industry_practice_chart(df, industries, selected_practices, params)
        else:
            # Filter practices and show regular visualization
            filtered_practices = selected_practices
            return create_filtered_practice_visualization(df, filtered_practices, countries, continents, industries, params)

    # Original visualization logic for when no practices are selected
    if industries and not (continents or countries):
        return create_industry_visualization(df, industries, params)
    elif industries:
        # Check if it's a single industry with multiple regions case
        if len(industries) == 1 and num_regions >= 2:
            return create_left_aligned_industry_chart(df, industries[0], countries, continents, params)
        else:
            return create_industry_subplots(df, industries, countries, continents, params)
    else:
        return create_grouped_bar_chart(df, countries, continents, params)

def create_left_aligned_industry_chart(df, industry, countries, continents, params):
    """Create a left-aligned chart for single industry with multiple regions"""

    # Filter data for the specific industry
    industry_data = df[df['industry_new'] == industry]

    if len(industry_data) < 4:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P(f"No sufficient data available for {industry} industry.",
                   className="text-center text-muted"),
            html.P("Please try selecting different filters or ensure the industry has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    # Determine grouping - prioritize countries over continents
    if countries:
        region_col = 'COUNTRY HEADQUARTERS'
        regions = countries
        region_label = 'Country'
    else:
        region_col = 'Continent'
        regions = continents
        region_label = 'Continent'

    # Check if any regions have sufficient data
    valid_regions = []
    for region in regions:
        region_data = industry_data[industry_data[region_col] == region]
        if len(region_data) >= 4:
            valid_regions.append(region)

    if not valid_regions:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P(f"No sufficient data available for {industry} industry in the selected regions.",
                   className="text-center text-muted"),
            html.P("Please try selecting different regions or ensure each region has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Since we only have one series (one industry), set narrow bar width
    uniform_bar_width = 0.3  # Narrow bars for single series

    for i, region in enumerate(valid_regions):
        region_data = industry_data[industry_data[region_col] == region]

        region_y_vals = []
        region_text_vals = []

        for p in practices:
            count = region_data[p].sum()
            percentage = (count/len(region_data))*100 if count else 0
            region_y_vals.append(percentage)
            region_text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=practices,
            x=region_y_vals,
            text=region_text_vals,
            textposition='outside',
            name=region,
            marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate=f"{region_label}: {region}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>"
        ))

    # Adjust height for left-aligned layout
    chart_height = 600 if params['font_size'] > 12 else 500

    fig.update_layout(
        title=f"Industry: {industry}",
        title_font=dict(size=params['title_font_size']),
        height=chart_height,
        margin=dict(l=200, r=50, t=60, b=80),  # Reduced margins for left alignment
        barmode='group',
        bargap=0.2,
        bargroupgap=0.15,
        plot_bgcolor='white',
        paper_bgcolor='white',
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        xaxis=dict(
            tickfont=dict(size=params['font_size']),
            linewidth=1,
            linecolor='gray',
            showgrid=True,
            gridcolor='lightgray',
            gridwidth=0.5
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    # Return the chart in a left-aligned column layout
    return dbc.Row([
        dbc.Col([
            dcc.Graph(
                figure=fig,
                style={"height": f"{chart_height}px", "width": "100%"},
                config={'responsive': True, 'displayModeBar': False}
            )
        ], width=8, lg=7),  # Takes up 8/12 columns on medium screens, 7/12 on large screens
        dbc.Col([], width=4, lg=5)  # Empty column on the right
    ], className="justify-content-start")

def create_industry_practice_chart(df, industries, selected_practices, params):
    """Create a horizontal bar chart showing selected practices broken down by selected industries"""

    # Check if any industry has sufficient data
    has_data = False
    for industry in industries:
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) >= 4:
            has_data = True
            break

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected industries and practices.",
                   className="text-center text-muted"),
            html.P("Please try selecting different industries or ensure each industry has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Calculate uniform bar width based on the number of industries
    max_bars_per_group = len(industries)

    # Special handling for single bars to prevent them from being too wide
    if max_bars_per_group == 1:
        uniform_bar_width = 0.3  # Much narrower for single bars
    else:
        uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    for i, industry in enumerate(industries):
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) < 4:
            continue

        y_vals = []
        text_vals = []

        # Only process selected practices instead of all practices
        for practice in selected_practices:
            count = industry_data[practice].sum()
            percentage = (count/len(industry_data))*100 if count else 0
            y_vals.append(percentage)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=selected_practices,  # Use selected_practices instead of all practices
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name=industry,
            marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate=f"Industry: {industry}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>"
        ))

    # Dynamic title based on selected practices
    if len(selected_practices) == 1:
        title = f"Adoption of {selected_practices[0]} by Industry"
    elif len(selected_practices) == 2:
        title = f"Adoption of {selected_practices[0]} and {selected_practices[1]} by Industry"
    else:
        title = f"Adoption of Selected Practices by Industry"

    fig.update_layout(
        title=title,
        title_font=dict(size=params['title_font_size']),
        height=max(400, len(selected_practices) * 80 + 200),  # Dynamic height based on practices
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=80,
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        xaxis=dict(
            tickfont=dict(size=params['font_size']),
            linewidth=1,
            linecolor='gray',
            showgrid=True,
            gridcolor='lightgray',
            gridwidth=0.5
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{max(400, len(selected_practices) * 80 + 200)}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_single_practice_chart(df, practice, industries, countries, continents, params):
    """Create a single bar chart for one practice across multiple industries and regions"""

    # Determine grouping - prioritize countries over continents
    if countries:
        region_col = 'COUNTRY HEADQUARTERS'
        regions = countries
        region_label = 'Country'
    else:
        region_col = 'Continent'
        regions = continents
        region_label = 'Continent'

    # Check if any data exists for the selected filters
    has_data = False
    for industry in industries:
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) < 4:
            continue
        for region in regions:
            region_data = industry_data[industry_data[region_col] == region]
            if len(region_data) >= 4:
                has_data = True
                break
        if has_data:
            break

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected combination of practice, industries, and regions.",
                   className="text-center text-muted"),
            html.P("Please try selecting different filters or ensure each region has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Calculate uniform bar width based on the number of regions
    max_bars_per_group = len(industries)

    # Special handling for single bars to prevent them from being too wide
    if max_bars_per_group == 1:
        uniform_bar_width = 0.3  # Much narrower for single bars
    else:
        uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    # Create bars for each industry
    for i, industry in enumerate(industries):
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) < 4:
            continue

        x_vals = []
        text_vals = []
        hover_regions = []

        for region in regions:
            region_data = industry_data[industry_data[region_col] == region]
            if len(region_data) >= 4:
                count = region_data[practice].sum()
                percentage = (count/len(region_data))*100 if count else 0
                x_vals.append(percentage)
                text_vals.append(str(int(count)) if count > 0 else "")
                hover_regions.append(region)
            else:
                x_vals.append(0)
                text_vals.append("")
                hover_regions.append(region)

        fig.add_trace(go.Bar(
            x=x_vals,
            y=hover_regions,
            text=text_vals,
            textposition='outside',
            name=industry,
            marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate=f"Industry: {industry}<br>{region_label}: %{{y}}<br>{practice}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>"
        ))

    fig.update_layout(
        title=f"Adoption of {practice} by Industry and {region_label}",
        title_font=dict(size=params['title_font_size']),
        height=params['height_single'],
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=100,
            b=params['margin_bottom']
        ),
        barmode='group',
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        xaxis_title="Percentage of Companies",
        yaxis_title=region_label,
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray'
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_practice_subplots(df, selected_practices, industries, countries, continents, params):
    """Create subplots for each practice with industries on y-axis and regions as grouped bars"""
    # Determine grouping - prioritize countries over continents
    if countries:
        region_col = 'COUNTRY HEADQUARTERS'
        regions = countries
        region_label = 'Country'
    else:
        region_col = 'Continent'
        regions = continents
        region_label = 'Continent'

    # Check if any data exists for the selected filters
    has_data = False
    for practice in selected_practices:
        for industry in industries:
            industry_data = df[df['industry_new'] == industry]
            if len(industry_data) < 4:
                continue
            for region in regions:
                region_data = industry_data[industry_data[region_col] == region]
                if len(region_data) >= 4:
                    has_data = True
                    break
            if has_data:
                break
        if has_data:
            break

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected combination of practices, industries, and regions.",
                   className="text-center text-muted"),
            html.P("Please try selecting different filters or ensure each region has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "600px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    num_practices = len(selected_practices)

    # Always use 2x2 layout for multiple practices (up to 4)
    rows, cols = 2, 2
    practices_padded = selected_practices + [''] * (4 - len(selected_practices))

    fig = make_subplots(
        rows=2,
        cols=2,
        subplot_titles=practices_padded,
        vertical_spacing=params['subplot_spacing_v'],
        horizontal_spacing=params['subplot_spacing_h']
    )

    # Calculate uniform bar width based on the maximum number of regions
    max_bars_per_group = len(regions)
    uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    legend_regions = {}

    for idx, practice in enumerate(practices_padded):
        if not practice:  # Skip empty slots
            continue

        r, c = divmod(idx, 2)
        row, col = r + 1, c + 1

        # Add bars for each region
        for j, region in enumerate(regions):
            y_vals = []
            text_vals = []
            hover_industries = []

            for industry in industries:
                industry_data = df[df['industry_new'] == industry]
                region_data = industry_data[industry_data[region_col] == region]

                if len(region_data) >= 4:
                    count = region_data[practice].sum()
                    percentage = (count/len(region_data))*100 if count else 0
                    y_vals.append(percentage)
                    text_vals.append(str(int(count)) if count > 0 else "")
                else:
                    y_vals.append(0)
                    text_vals.append("")
                hover_industries.append(industry)

            show_in_legend = region not in legend_regions
            if show_in_legend:
                legend_regions[region] = True

            fig.add_trace(go.Bar(
                x=y_vals,
                y=hover_industries,
                text=text_vals,
                textposition='outside',
                name=region,
                marker_color=COLOR_PALETTE[j % len(COLOR_PALETTE)],
                orientation='h',
                width=uniform_bar_width,
                textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                hovertemplate=f"{region_label}: {region}<br>Industry: %{{y}}<br>{practice}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>",
                showlegend=show_in_legend
            ), row=row, col=col)

    fig.update_layout(
        height=params['height_subplots'],
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=params['margin_top'],
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    # Update axes for each subplot
    for idx in range(4):  # Always 4 subplots in 2x2 grid
        r, c = divmod(idx, 2)
        row, col = r + 1, c + 1

        # Show x-axis title only on bottom subplots
        show_x_title = (row == 2)

        fig.update_xaxes(
            title_text="Percentage of Companies" if show_x_title else "",
            title_font=dict(size=params['font_size']),
            tickfont=dict(size=params['font_size'] - 1),
            linewidth=1,
            linecolor='gray',
            row=row,
            col=col
        )

        # Show y-axis labels on all subplots
        fig.update_yaxes(
            title_text="Industries" if col == 1 else "",
            title_font=dict(size=params['font_size']),
            tickfont=dict(size=params['font_size']),
            linewidth=1,
            linecolor='gray',
            row=row,
            col=col
        )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_subplots']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_filtered_practice_visualization(df, filtered_practices, countries, continents, industries, params):
    """Create visualization with filtered practices"""

    if countries:
        col, groups, label = 'COUNTRY HEADQUARTERS', countries, 'Country'
    elif continents:
        col, groups, label = 'Continent', continents, 'Continent'
    else:
        col, groups, label = None, ['All Companies'], ''

    # Check if any data exists for the selected filters
    has_data = False
    if col:
        for g in groups:
            group_data = df[df[col] == g]
            if len(group_data) >= 4:
                has_data = True
                break
    else:
        has_data = len(df) >= 4

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected combination of practices and regions.",
                   className="text-center text-muted"),
            html.P("Please try selecting different filters or ensure each region has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Calculate uniform bar width based on the number of groups
    max_bars_per_group = len(groups) if col else 1

    # Special handling for single bars to prevent them from being too wide
    if max_bars_per_group == 1:
        uniform_bar_width = 0.3  # Much narrower for single bars
    else:
        uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    if col:
        for i, g in enumerate(groups):
            group_data = df[df[col] == g]
            if len(group_data) < 4:
                continue

            y_vals = []
            text_vals = []
            for p in filtered_practices:
                count = group_data[p].sum()
                y_vals.append((count/len(group_data))*100 if count else 0)
                text_vals.append(str(int(count)) if count > 0 else "")

            fig.add_trace(go.Bar(
                y=filtered_practices,
                x=y_vals,
                text=text_vals,
                textposition='outside',
                name=g,
                marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
                orientation='h',
                width=uniform_bar_width,
                textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                hovertemplate=f"{label}: {g}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>"
            ))
    else:
        y_vals = []
        text_vals = []
        for p in filtered_practices:
            count = df[p].sum()
            y_vals.append((count/len(df))*100 if count else 0)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=filtered_practices,
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name="All Companies",
            marker_color=WHARTON_BLUE,
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate="All Companies<br>%{y}: %{x:.1f}%<br>Count: %{text}<extra></extra>"
        ))

    fig.update_layout(
        height=params['height_single'],
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=50,
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_grouped_bar_chart(df, countries, continents, params):

    if countries:
        col, groups, label = 'COUNTRY HEADQUARTERS', countries, 'Country'
    elif continents:
        col, groups, label = 'Continent', continents, 'Continent'
    else:
        col, groups, label = None, ['All Companies'], ''

    # Check if any data exists for the selected filters
    has_data = False
    if col:
        for g in groups:
            group_data = df[df[col] == g]
            if len(group_data) >= 4:
                has_data = True
                break
    else:
        has_data = len(df) >= 4

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected filters.",
                   className="text-center text-muted"),
            html.P("Please try selecting different filters or ensure each region has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Calculate uniform bar width based on the number of groups
    max_bars_per_group = len(groups) if col else 1

    # Special handling for single bars to prevent them from being too wide
    if max_bars_per_group == 1:
        uniform_bar_width = 0.3  # Much narrower for single bars
    else:
        uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    if col:
        for i, g in enumerate(groups):
            group_data = df[df[col] == g]
            if len(group_data) < 4:
                continue

            y_vals = []
            text_vals = []
            for p in practices:
                count = group_data[p].sum()
                y_vals.append((count/len(group_data))*100 if count else 0)
                text_vals.append(str(int(count)) if count > 0 else "")

            fig.add_trace(go.Bar(
                y=practices,
                x=y_vals,
                text=text_vals,
                textposition='outside',
                name=g,
                marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
                orientation='h',
                width=uniform_bar_width,
                textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                hovertemplate=f"{label}: {g}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>"
            ))
    else:
        y_vals = []
        text_vals = []
        for p in practices:
            count = df[p].sum()
            y_vals.append((count/len(df))*100 if count else 0)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=practices,
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name="All Companies",
            marker_color=WHARTON_BLUE,
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate="All Companies<br>%{y}: %{x:.1f}%<br>Count: %{text}<extra></extra>"
        ))

    fig.update_layout(
        height=params['height_single'],
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=50,
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_industry_visualization(df, industries, params):

    # Check if any industry has sufficient data
    has_data = False
    for industry in industries:
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) >= 4:
            has_data = True
            break

    if not has_data:
        return html.Div([
            html.H5("No Data Available", className="text-center text-danger mb-3"),
            html.P("No data available for the selected industries.",
                   className="text-center text-muted"),
            html.P("Please try selecting different industries or ensure each industry has at least 4 companies.",
                   className="text-center text-muted small")
        ], className="p-4 text-center", style={"height": "400px", "display": "flex", "flex-direction": "column", "justify-content": "center"})

    fig = go.Figure()

    # Calculate uniform bar width based on the number of industries
    max_bars_per_group = len(industries)

    # Special handling for single bars to prevent them from being too wide
    if max_bars_per_group == 1:
        uniform_bar_width = 0.3  # Much narrower for single bars
    else:
        uniform_bar_width = 0.8 / max_bars_per_group if max_bars_per_group > 0 else 0.8

    for i, industry in enumerate(industries):
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) < 4:
            continue

        y_vals = []
        text_vals = []
        for p in practices:
            count = industry_data[p].sum()
            y_vals.append((count/len(industry_data))*100 if count else 0)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=practices,
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name=industry,
            marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
            orientation='h',
            width=uniform_bar_width,
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate="Industry: %{fullData.name}<br>%{y}: %{x:.1f}%<br>Count: %{text}<extra></extra>"
        ))

    fig.update_layout(
        height=params['height_single'] - 100,
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=40,
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single'] - 100}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_industry_subplots(df, industries, countries, continents, params):
    actual_industries = [i for i in industries if i]
    num_industries = len(actual_industries)

    # Progressive subplot layout based on number of industries
    if params['use_vertical_subplots']:
        # Mobile: always vertical stacking
        rows, cols = num_industries, 1
        subplot_layout = [(i+1, 1) for i in range(num_industries)]
    else:
        # Desktop: efficient grid layouts
        if num_industries == 1:
            rows, cols = 1, 1
            subplot_layout = [(1, 1)]
        elif num_industries == 2:
            rows, cols = 1, 2
            subplot_layout = [(1, 1), (1, 2)]
        elif num_industries == 3:
            rows, cols = 2, 2
            subplot_layout = [(1, 1), (1, 2), (2, 1)]
        else:  # 4 industries
            rows, cols = 2, 2
            subplot_layout = [(1, 1), (1, 2), (2, 1), (2, 2)]

    # Create subplot titles
    subplot_titles = [f"Industry: {industry}" for industry in actual_industries]

    fig = make_subplots(
        rows=rows,
        cols=cols,
        subplot_titles=subplot_titles,
        horizontal_spacing=params['subplot_spacing_h'] if cols > 1 else 0,
        vertical_spacing=params['subplot_spacing_v']
    )

    # Logic for region selection
    if countries:
        group_col = 'COUNTRY HEADQUARTERS'
        groups = [g for g in countries if g in df['COUNTRY HEADQUARTERS'].unique()]
        label = 'Country'
    elif continents:
        group_col = 'Continent'
        groups = [g for g in continents if g in df['Continent'].unique()]
        label = 'Continent'
    else:
        group_col, groups, label = None, ['All'], ''

    # Calculate maximum number of groups across all subplots for uniform bar width
    max_groups_across_subplots = 0
    industries_with_data = {}

    if group_col:
        for industry in actual_industries:
            industry_data = df[df['industry_new'] == industry]
            valid_groups_count = 0

            for g in groups:
                group_data = industry_data[industry_data[group_col] == g]
                if len(group_data) >= 4:
                    valid_groups_count += 1

            max_groups_across_subplots = max(max_groups_across_subplots, valid_groups_count)
            industries_with_data[industry] = valid_groups_count > 0
    else:
        max_groups_across_subplots = 1
        for industry in actual_industries:
            industry_data = df[df['industry_new'] == industry]
            industries_with_data[industry] = len(industry_data) >= 4

    # Calculate uniform bar width based on maximum number of groups
    uniform_bar_width = 0.8 / max_groups_across_subplots if max_groups_across_subplots > 0 else 0.8

    legend_groups = {}

    for idx, industry in enumerate(actual_industries):
        row, col = subplot_layout[idx]

        # Always add gridlines between practices - aligned across subplots
        for i in range(len(practices) - 1):
            fig.add_shape(
                type="line",
                x0=0,
                y0=i + 0.5,
                x1=1,
                y1=i + 0.5,
                line=dict(
                    color="rgba(150,150,150,0.3)",
                    width=1,
                    dash="dash"
                ),
                xref=f"x{idx+1} domain" if idx > 0 else "x domain",
                yref=f"y{idx+1}" if idx > 0 else "y",
                row=row,
                col=col
            )

        # Always show practice names on y-axis
        fig.update_yaxes(
            tickvals=list(range(len(practices))),
            ticktext=practices,
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            range=[-0.5, len(practices) - 0.5],  # Lock the range
            row=row,
            col=col
        )

        fig.update_xaxes(
            showline=True,
            linewidth=1,
            linecolor='gray',
            showgrid=False,
            zeroline=False,
            row=row,
            col=col
        )

        has_data_to_display = industries_with_data.get(industry, False)

        if not has_data_to_display:
            # Add "No data" message positioned under the subplot title
            fig.add_annotation(
                text="No data available",
                xref=f"x{idx+1} domain" if idx > 0 else "x domain",  # Use domain reference
                yref=f"y{idx+1} domain" if idx > 0 else "y domain",  # Use domain reference
                x=0.5,  # Center horizontally (50% of subplot width)
                y=0.85,  # Position near top (85% from bottom, under title)
                showarrow=False,
                font=dict(size=params['font_size'], color=WHARTON_RED, family="Arial, sans-serif"),
                align="center",
                bgcolor="rgba(255,255,255,0.8)",
                bordercolor="rgba(153,0,0,0.3)",
                borderwidth=1,
                borderpad=4
            )
            continue

        industry_data = df[df['industry_new'] == industry]

        if group_col:
            for j, g in enumerate(groups):
                group_data = industry_data[industry_data[group_col] == g]

                if len(group_data) < 4:
                    continue

                y_vals = []
                text_vals = []
                for p in practices:
                    count = group_data[p].sum()
                    y_vals.append((count/len(group_data))*100 if count else 0)
                    text_vals.append(str(int(count)) if count > 0 else "")

                show_in_legend = g not in legend_groups
                if show_in_legend:
                    legend_groups[g] = True

                fig.add_trace(go.Bar(
                    y=practices,
                    x=y_vals,
                    text=text_vals,
                    textposition='outside',
                    name=g,
                    marker_color=COLOR_PALETTE[j % len(COLOR_PALETTE)],
                    orientation='h',
                    width=uniform_bar_width,
                    textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                    hovertemplate=f"{label}: {g}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>",
                    showlegend=show_in_legend
                ), row=row, col=col)

    # Calculate dynamic height based on number of subplots
    if num_industries == 1:
        subplot_height = params['height_single']
    elif num_industries == 2:
        subplot_height = params['height_subplots'] * 0.6
    else:
        subplot_height = params['height_subplots']

    fig.update_layout(
        height=subplot_height,
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=params['margin_top'],
            b=params['margin_bottom']
        ),
        bargap=0.2,  # Space between groups
        bargroupgap=0.15,  # Space between bars within groups
        plot_bgcolor='white',
        paper_bgcolor='white',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        ),
        yaxis_tickfont_size=params['font_size'],
        title_font=dict(size=params['title_font_size'])
    )

    # Configure x-axes for actual subplots only
    for idx, industry in enumerate(actual_industries):
        row, col = subplot_layout[idx]

        # Show x-axis title on bottom row subplots
        show_x_title = (row == rows)

        fig.update_xaxes(
            title_text="Percentage of Companies" if show_x_title else "",
            title_font=dict(size=params['font_size']),
            tickfont=dict(size=params['font_size'] - 1),
            linewidth=1,
            linecolor='gray',
            gridcolor='lightgray',
            gridwidth=0.5,
            range=[0, max(100, df[practices].sum(axis=1).max() / len(df) * 100 * 1.2)],
            showgrid=True,
            zeroline=True,
            zerolinecolor='rgba(0, 0, 0, 0.3)',
            zerolinewidth=1.5,
            row=row,
            col=col
        )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{subplot_height}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 8050))
    app.run(host="0.0.0.0", port=port, debug=True, dev_tools_ui=False)


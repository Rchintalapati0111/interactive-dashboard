# -*- coding: utf-8 -*-
"""Final_interactive_dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1daAlBB6C2GfH_f2CkX90X2Uj-OMLLWVX

# Visualization:
"""

import pandas as pd
import os
import dash
import dash_bootstrap_components as dbc
from dash import dcc, html, clientside_callback, ClientsideFunction
from dash.dependencies import Input, Output, State
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Load Data:
file_path = 'Cleaned_data_sheet.xlsx'
try:
    data = pd.read_excel(file_path)
    data.columns = data.columns.str.strip()
except Exception as e:
    print(f"Error loading data: {e}")
    data = pd.DataFrame()

practices = ['Corporate Venture Capital', 'Accelerators & Incubators', 'Venture Building', 'Venture Clienting',
             'Mentorship', 'Business services', 'Workspace', 'Events']

# Define Wharton color palette:
WHARTON_BLUE = '#011F5B'
WHARTON_RED = '#990000'

# Extended palette based on Wharton/Penn colors with complementary colors:
WHARTON_PALETTE = [
    WHARTON_BLUE,
    WHARTON_RED,
    '#2457A7',
    '#C1292E',
    '#4E6396',
    '#D9D9D9',
    '#6A7A99',
    '#BF616A'
]

COLOR_PALETTE = WHARTON_PALETTE

# Create a mapping of continents to their countries:
continent_to_countries = {}
for continent in data['Continent'].unique():
    countries_in_continent = data[data['Continent'] == continent]['COUNTRY HEADQUARTERS'].unique()
    continent_to_countries[continent] = sorted(countries_in_continent)

# Filter regions with at least 4 companies:
country_counts = data['COUNTRY HEADQUARTERS'].value_counts()
valid_countries = country_counts[country_counts >= 4].index.tolist()

continent_counts = data['Continent'].value_counts()
valid_continents = continent_counts[continent_counts >= 4].index.tolist()

# App Setup with responsive theme:
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Configure dev tools
app.config.suppress_callback_exceptions = True

# Add responsive meta tag
app.index_string = '''
<!DOCTYPE html>
<html>
    <head>
        {%metas%}
        <title>{%title%}</title>
        {%favicon%}
        {%css%}
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            /* Always apply base padding */
            .container-fluid {
                padding-left: 10px !important;
                padding-right: 10px !important;
            }

            /* Mobile-first responsive styles */
            @media (max-width: 768px) {
                .container-fluid {
                    padding-left: 2px !important;
                    padding-right: 2px !important;
                }

                .card-body {
                    padding: 0.25rem !important;
                }

                h1 {
                    font-size: 1.1rem !important;
                    margin-bottom: 0.5rem !important;
                    line-height: 1.2 !important;
                }

                h4 {
                    font-size: 0.9rem !important;
                }

                .dropdown {
                    margin-bottom: 0.25rem !important;
                }

                .small {
                    font-size: 0.65rem !important;
                }

                .text-danger {
                    font-size: 0.6rem !important;
                }

                .fw-bold {
                    font-size: 0.7rem !important;
                }
            }

            @media (max-width: 480px) {
                h1 {
                    font-size: 0.95rem !important;
                    padding: 0 5px !important;
                }

                .card-header h4 {
                    font-size: 0.8rem !important;
                }

                .container-fluid {
                    padding-left: 1px !important;
                    padding-right: 1px !important;
                }
            }
        </style>
    </head>
    <body>
        {%app_entry%}
        <footer>
            {%config%}
            {%scripts%}
            {%renderer%}
        </footer>
    </body>
</html>
'''

# Updated Layout with responsive classes:
app.layout = dbc.Container(fluid=True, className="px-0 px-md-3", children=[
    dbc.Row([
        dbc.Col(html.H1("How are Corporate Venturing Practices Adopted Across Regions and Industries?",
                       className="text-center mb-1 mb-md-4"), width=12)
    ]),

    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Filters", className="text-primary mb-0")),
                dbc.CardBody([
                    dbc.Row([
                        dbc.Col([
                            html.Label("Select Continent(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='continent-dropdown',
                                options=[{'label': cont, 'value': cont} for cont in sorted(valid_continents)],
                                multi=True,
                                placeholder="Select up to 3 continents",
                                className="mb-1"
                            ),
                            html.Div(id='continent-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=4),
                        dbc.Col([
                            html.Label("Select Country(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='country-dropdown',
                                options=[],
                                multi=True,
                                placeholder="Select up to 3 countries",
                                className="mb-1"
                            ),
                            html.Div(id='country-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=4),
                        dbc.Col([
                            html.Label("Select Industry(s):", className="fw-bold small"),
                            dcc.Dropdown(
                                id='industry-dropdown',
                                options=[{'label': ind, 'value': ind} for ind in sorted(data['industry_new'].dropna().unique())],
                                multi=True,
                                placeholder="Select up to 4 industries",
                                className="mb-1"
                            ),
                            html.Div(id='industry-warning', style={'color': 'red', 'fontSize': '0.7rem'})
                        ], xs=12, md=4)
                    ]),

                    html.Div([
                        html.Hr(),
                        dbc.Row([
                            dbc.Col([
                                html.Div("NOTE: Numbers on the right hand side of the bars indicate the count of companies engaged in each practice",
                                        className="text-dark small"),
                                html.Div("Continents and countries with fewer than 4 companies according to the chosen filters are excluded from the chart",
                                        className="text-danger small"),
                                html.Div("When you select countries after selecting continents, the visualization will show data for countries only. Similarly, when you select industries along with continents and countries, you will see industry-specific visualizations for the countries you've chosen",
                                        className="text-dark small mt-2")
                            ])
                        ])
                    ], className="mt-2")
                ])
            ])
        ], width=12)
    ], className="mb-1 mb-md-4"),

    # Hidden div to store screen width
    html.Div(id='screen-width', style={'display': 'none'}),

    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    dcc.Loading(
                        id="loading-visualization",
                        type="circle",
                        children=html.Div(id='visualization-container')
                    )
                ])
            ])
        ], width=12)
    ])
])

# Clientside callback to get screen width
clientside_callback(
    """
    function() {
        return window.innerWidth;
    }
    """,
    Output('screen-width', 'children'),
    Input('screen-width', 'id')
)

# Helper function to get responsive layout parameters
def get_responsive_params(screen_width=None):
    # More aggressive mobile settings
    if screen_width is None or screen_width < 576:  # Very small phones
        return {
            'margin_left': 140,
            'margin_right': 5,
            'margin_top': 60,
            'margin_bottom': 40,
            'font_size': 11,
            'title_font_size': 11,
            'text_font_size': 11,
            'legend_font_size': 9,
            'height_single': 700,
            'height_subplots': 2000,  # Much taller for mobile
            'legend_x': 1.01,
            'legend_y': 0.99,
            'show_legend_text': False,
            'use_vertical_subplots': True,  # Stack subplots vertically
            'subplot_spacing_v': 0.25,
            'subplot_spacing_h': 0.15
        }
    elif screen_width < 768:  # Small phones/large phones
        return {
            'margin_left': 150,
            'margin_right': 8,
            'margin_top': 70,
            'margin_bottom': 50,
            'font_size': 12,
            'title_font_size': 12,
            'text_font_size': 12,
            'legend_font_size': 10,
            'height_single': 750,
            'height_subplots': 1800,
            'legend_x': 1.01,
            'legend_y': 0.99,
            'show_legend_text': False,
            'use_vertical_subplots': True,  # Stack subplots vertically
            'subplot_spacing_v': 0.22,
            'subplot_spacing_h': 0.15
        }
    elif screen_width < 992:  # Tablet
        return {
            'margin_left': 200,
            'margin_right': 30,
            'margin_top': 100,
            'margin_bottom': 80,
            'font_size': 11,
            'title_font_size': 13,
            'text_font_size': 12,
            'legend_font_size': 11,
            'height_single': 700,
            'height_subplots': 1400,
            'legend_x': 1.02,
            'legend_y': 0.99,
            'show_legend_text': True,
            'use_vertical_subplots': False,
            'subplot_spacing_v': 0.18,
            'subplot_spacing_h': 0.12
        }
    else:  # Desktop
        return {
            'margin_left': 300,
            'margin_right': 50,
            'margin_top': 150,
            'margin_bottom': 120,
            'font_size': 13,
            'title_font_size': 16,
            'text_font_size': 14,
            'legend_font_size': 13,
            'height_single': 800,
            'height_subplots': 1600,
            'legend_x': 1.02,
            'legend_y': 0.99,
            'show_legend_text': True,
            'use_vertical_subplots': False,
            'subplot_spacing_v': 0.16,
            'subplot_spacing_h': 0.12
        }

# Modified callbacks with responsive parameters
@app.callback(
    Output('country-dropdown', 'options'),
    [Input('continent-dropdown', 'value')]
)
def update_country_options(selected_continents):
    if not selected_continents:
        return [{'label': country, 'value': country} for country in sorted(valid_countries)]

    filtered_countries = []
    for continent in selected_continents:
        if continent in continent_to_countries:
            countries_in_continent = continent_to_countries[continent]
            valid_countries_in_continent = [c for c in countries_in_continent if c in valid_countries]
            filtered_countries.extend(valid_countries_in_continent)

    filtered_countries = sorted(set(filtered_countries))
    return [{'label': country, 'value': country} for country in filtered_countries]

@app.callback(
    Output('country-dropdown', 'value'),
    [Input('country-dropdown', 'options')],
    [State('country-dropdown', 'value')]
)
def reset_country_value(available_options, current_value):
    if not current_value:
        return current_value

    available_values = [option['value'] for option in available_options]
    valid_selections = [val for val in current_value if val in available_values]
    return valid_selections if valid_selections else None

@app.callback(
    [Output('continent-warning', 'children'),
     Output('country-warning', 'children'),
     Output('industry-warning', 'children'),
     Output('continent-dropdown', 'value', allow_duplicate=True),
     Output('industry-dropdown', 'value')],
    [Input('continent-dropdown', 'value'),
     Input('country-dropdown', 'value'),
     Input('industry-dropdown', 'value')],
    prevent_initial_call=True
)
def enforce_limits(continents, countries, industries):
    warn = {'continent': '', 'country': '', 'industry': ''}
    if continents and len(continents) > 3:
        warn['continent'] = "Maximum 3 continents allowed"
        continents = continents[:3]
    if countries and len(countries) > 3:
        warn['country'] = "Maximum 3 countries allowed"
        countries = countries[:3]
    if industries and len(industries) > 4:
        warn['industry'] = "Maximum 4 industries allowed"
        industries = industries[:4]
    return warn['continent'], warn['country'], warn['industry'], continents, industries

def get_filtered_data(continents, countries, industries):
    df = data.copy()
    if continents:
        df = df[df['Continent'].isin(continents)]
    if countries:
        df = df[df['COUNTRY HEADQUARTERS'].isin(countries)]
    if industries:
        df = df[df['industry_new'].isin(industries)]
    return df

@app.callback(
    Output('visualization-container', 'children'),
    [Input('continent-dropdown', 'value'),
     Input('country-dropdown', 'value'),
     Input('industry-dropdown', 'value'),
     Input('screen-width', 'children')]
)
def update_visualization(continents, countries, industries, screen_width):
    # Convert screen_width to int if it exists
    try:
        screen_width = int(screen_width) if screen_width else None
    except (ValueError, TypeError):
        screen_width = None

    df = get_filtered_data(continents, countries, industries)
    if df.empty:
        return html.Div("No data available for selected filters", className="text-center text-danger p-4")

    params = get_responsive_params(screen_width)

    if industries and not (continents or countries):
        return create_industry_visualization(df, industries, params)
    elif industries:
        return create_industry_subplots(df, industries, countries, continents, params)
    else:
        return create_grouped_bar_chart(df, countries, continents, params)

def create_grouped_bar_chart(df, countries, continents, params):
    fig = go.Figure()

    if countries:
        col, groups, label = 'COUNTRY HEADQUARTERS', countries, 'Country'
    elif continents:
        col, groups, label = 'Continent', continents, 'Continent'
    else:
        col, groups, label = None, ['All Companies'], ''

    # Calculate valid groups count for bar width consistency
    valid_groups_count = 0
    if col:
        for g in groups:
            group_data = df[df[col] == g]
            if len(group_data) >= 4:
                valid_groups_count += 1
    else:
        valid_groups_count = 1

    # Calculate bar width based on number of valid groups
    base_width = 0.6
    bar_width = base_width / max(1, valid_groups_count)
    bar_width = max(bar_width, 0.15)

    if col:
        for i, g in enumerate(groups):
            group_data = df[df[col] == g]
            if len(group_data) < 4:
                continue

            y_vals = []
            text_vals = []
            for p in practices:
                count = group_data[p].sum()
                y_vals.append((count/len(group_data))*100 if count else 0)
                text_vals.append(str(int(count)) if count > 0 else "")

            fig.add_trace(go.Bar(
                y=practices,
                x=y_vals,
                text=text_vals,
                textposition='outside',
                name=g,
                marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
                orientation='h',
                textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                hovertemplate=f"{label}: {g}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>",
                width=bar_width
            ))
    else:
        y_vals = []
        text_vals = []
        for p in practices:
            count = df[p].sum()
            y_vals.append((count/len(df))*100 if count else 0)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=practices,
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name="All Companies",
            marker_color=WHARTON_BLUE,
            orientation='h',
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate="All Companies<br>%{y}: %{x:.1f}%<br>Count: %{text}<extra></extra>",
            width=bar_width
        ))

    fig.update_layout(
        height=params['height_single'],
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=50,
            b=params['margin_bottom']
        ),
        bargap=0.4,
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_industry_visualization(df, industries, params):
    fig = go.Figure()

    # Calculate valid industries count for bar width consistency
    valid_industries_count = 0
    for industry in industries:
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) >= 4:
            valid_industries_count += 1

    # Calculate bar width based on number of valid industries
    base_width = 0.6
    bar_width = base_width / max(1, valid_industries_count)
    bar_width = max(bar_width, 0.15)

    for i, industry in enumerate(industries):
        industry_data = df[df['industry_new'] == industry]
        if len(industry_data) < 4:
            continue

        y_vals = []
        text_vals = []
        for p in practices:
            count = industry_data[p].sum()
            y_vals.append((count/len(industry_data))*100 if count else 0)
            text_vals.append(str(int(count)) if count > 0 else "")

        fig.add_trace(go.Bar(
            y=practices,
            x=y_vals,
            text=text_vals,
            textposition='outside',
            name=industry,
            marker_color=COLOR_PALETTE[i % len(COLOR_PALETTE)],
            orientation='h',
            textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
            hovertemplate="Industry: %{fullData.name}<br>%{y}: %{x:.1f}%<br>Count: %{text}<extra></extra>",
            width=bar_width
        ))

    fig.update_layout(
        height=params['height_single'] - 100,
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=40,
            b=params['margin_bottom']
        ),
        bargap=0.3,
        plot_bgcolor='white',
        paper_bgcolor='white',
        yaxis_tickfont_size=params['font_size'],
        xaxis_title="Percentage of Companies",
        yaxis_title="Corporate Venturing Practices",
        xaxis_title_font=dict(size=params['font_size']),
        yaxis_title_font=dict(size=params['font_size']),
        yaxis=dict(
            ticksuffix='   ',
            tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
            linewidth=1,
            linecolor='gray',
            showgrid=False
        ),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        )
    )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_single'] - 100}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

def create_industry_subplots(df, industries, countries, continents, params):
    actual_industries = [i for i in industries if i]

    # For mobile, use vertical layout (4 rows, 1 column)
    if params['use_vertical_subplots']:
        rows, cols = 4, 1
        industries = actual_industries + [''] * (4 - len(actual_industries))

        fig = make_subplots(
            rows=4,
            cols=1,
            subplot_titles=[f"{i}" if i else "" for i in industries],  # Shorter titles for mobile
            vertical_spacing=params['subplot_spacing_v']
        )
    else:
        # Desktop layout (2 rows, 2 columns)
        rows, cols = 2, 2
        industries = actual_industries + [''] * (4 - len(actual_industries))

        fig = make_subplots(
            rows=2,
            cols=2,
            subplot_titles=[f"Industry: {i}" if i else "" for i in industries],
            horizontal_spacing=params['subplot_spacing_h'],
            vertical_spacing=params['subplot_spacing_v']
        )

    # Logic for region selection
    if countries:
        group_col = 'COUNTRY HEADQUARTERS'
        groups = [g for g in countries if g in df['COUNTRY HEADQUARTERS'].unique()]
        label = 'Country'
    elif continents:
        group_col = 'Continent'
        groups = [g for g in continents if g in df['Continent'].unique()]
        label = 'Continent'
    else:
        group_col, groups, label = None, ['All'], ''

    max_valid_groups = 0
    industries_with_data = {}

    if group_col:
        for industry in actual_industries:
            industry_data = df[df['industry_new'] == industry]
            valid_groups_count = 0

            for g in groups:
                group_data = industry_data[industry_data[group_col] == g]
                if len(group_data) >= 4:
                    valid_groups_count += 1

            max_valid_groups = max(max_valid_groups, valid_groups_count)
            industries_with_data[industry] = valid_groups_count > 0
    else:
        max_valid_groups = 1
        for industry in actual_industries:
            industry_data = df[df['industry_new'] == industry]
            industries_with_data[industry] = len(industry_data) >= 4

    # Calculate bar width
    base_width = 0.6
    bar_width = base_width / max(1, max_valid_groups)
    bar_width = max(bar_width, 0.15)

    legend_groups = {}
    any_subplot_has_data = any(industries_with_data.get(ind, False) for ind in actual_industries)

    for idx, industry in enumerate(industries):
        if not industry:
            continue

        if params['use_vertical_subplots']:
            row, col = idx + 1, 1
        else:
            r, c = divmod(idx, 2)
            row, col = r + 1, c + 1

        industry_data = df[df['industry_new'] == industry]
        has_data_to_display = industries_with_data.get(industry, False)

        # Add horizontal separators between practice rows
        if any_subplot_has_data:
            for i in range(len(practices) - 1):
                fig.add_shape(
                    type="line",
                    x0=0,
                    y0=i + 0.5,
                    x1=1,
                    y1=i + 0.5,
                    line=dict(
                        color="rgba(150,150,150,0.3)",
                        width=1,
                        dash="dash"
                    ),
                    xref=f"x{idx+1} domain" if idx > 0 else "x domain",
                    yref=f"y{idx+1}" if idx > 0 else "y",
                    row=row,
                    col=col
                )

        if not has_data_to_display:
            # Calculate position for "No data" message
            title_y = fig.layout.annotations[idx].y if idx < len(fig.layout.annotations) else 0.5

            if params['use_vertical_subplots']:
                x_center = 0.5
            else:
                if row == 1 and col == 1:
                    x_center = 0.12
                elif row == 1 and col == 2:
                    x_center = 0.90
                elif row == 2 and col == 1:
                    x_center = 0.12
                elif row == 2 and col == 2:
                    x_center = 0.90
                else:
                    x_center = 0.5

            vertical_margin = 0.05

            fig.update_yaxes(
                tickvals=list(range(len(practices))),
                ticktext=practices,
                ticksuffix='   ',
                tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
                linewidth=1,
                linecolor='gray',
                row=row,
                col=col)

            fig.update_xaxes(
               showline=True,
               linewidth=1,
               linecolor='gray',
               showgrid=False,
               zeroline=False,
               row=row,
               col=col
               )

            fig.add_annotation(
                text="No data available",
                xref="paper",
                yref="paper",
                x=x_center,
                y=title_y - vertical_margin,
                showarrow=False,
                font=dict(size=params['font_size'], color=WHARTON_RED, family="Arial, sans-serif"),
                align="center",
                bgcolor="rgba(255,255,255,0.8)",
                bordercolor="rgba(153,0,0,0.3)",
                borderwidth=1,
                borderpad=4
            )
            continue

        if group_col:
            for j, g in enumerate(groups):
                group_data = industry_data[industry_data[group_col] == g]

                if len(group_data) < 4:
                    continue

                y_vals = []
                text_vals = []
                for p in practices:
                    count = group_data[p].sum()
                    y_vals.append((count/len(group_data))*100 if count else 0)
                    text_vals.append(str(int(count)) if count > 0 else "")

                show_in_legend = g not in legend_groups
                if show_in_legend:
                    legend_groups[g] = True

                fig.add_trace(go.Bar(
                    y=practices,
                    x=y_vals,
                    text=text_vals,
                    textposition='outside',
                    name=g,
                    marker_color=COLOR_PALETTE[j % len(COLOR_PALETTE)],
                    orientation='h',
                    textfont=dict(size=params['text_font_size'], color='black', family="Arial, sans-serif"),
                    hovertemplate=f"{label}: {g}<br>%{{y}}: %{{x:.1f}}%<br>Count: %{{text}}<extra></extra>",
                    showlegend=show_in_legend,
                    width=bar_width
                ), row=row, col=col)

    fig.update_layout(
        height=params['height_subplots'],
        barmode='group',
        margin=dict(
            l=params['margin_left'],
            r=params['margin_right'],
            t=params['margin_top'],
            b=params['margin_bottom']
        ),
        bargap=0.35,
        bargroupgap=0.15,
        plot_bgcolor='white',
        paper_bgcolor='white',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=params['legend_y'],
            xanchor="left",
            x=params['legend_x'],
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="LightGray",
            borderwidth=1,
            font=dict(size=params['legend_font_size'])
        ),
        yaxis_tickfont_size=params['font_size'],
        title_font=dict(size=params['title_font_size'])
    )

    # Configure axes for subplots with data
    for idx, industry in enumerate(industries):
        if not industry:
            continue

        if params['use_vertical_subplots']:
            row, col = idx + 1, 1
        else:
            r, c = divmod(idx, 2)
            row, col = r + 1, c + 1

        has_data = industries_with_data.get(industry, False)

        if has_data:
            # Show x-axis title only on the bottom subplot(s)
            show_x_title = (params['use_vertical_subplots'] and row == 4) or (not params['use_vertical_subplots'] and row == 2)

            fig.update_xaxes(
                title_text="Percentage of Companies" if show_x_title else "",
                title_font=dict(size=params['font_size']),
                tickfont=dict(size=params['font_size'] - 1),
                linewidth=1,
                linecolor='gray',
                gridcolor='lightgray',
                gridwidth=0.5,
                range=[0, max(100, df[practices].sum(axis=1).max() / len(df) * 100 * 1.2)],
                showgrid=True,
                zeroline=True,
                zerolinecolor='rgba(0, 0, 0, 0.3)',
                zerolinewidth=1.5,
                row=row,
                col=col
            )

            # For vertical layout, show y-axis labels on all subplots
            # For horizontal layout, show only on left column
            show_y_labels = params['use_vertical_subplots'] or col == 1

            if show_y_labels:
                fig.update_yaxes(
                    tickfont=dict(size=params['font_size'], family="Arial, sans-serif"),
                    ticksuffix='   ',
                    linewidth=1,
                    linecolor='gray',
                    row=row,
                    col=col
                )
            else:
                fig.update_yaxes(
                    showticklabels=False,
                    ticksuffix='   ',
                    showline=True,
                    linecolor='gray',
                    linewidth=1,
                    row=row,
                    col=col
                )

    return dcc.Graph(
        figure=fig,
        style={"height": f"{params['height_subplots']}px", "width": "100%"},
        config={'responsive': True, 'displayModeBar': False}
    )

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 8050))
    app.run(host="0.0.0.0", port=port, debug=True, dev_tools_ui=False)

